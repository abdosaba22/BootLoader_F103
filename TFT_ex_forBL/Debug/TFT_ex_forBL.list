
TFT_ex_forBL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08001000  08001000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000007c4  08001130  08001130  00001130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000a000  080018f4  080018f4  000018f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800b8f4  0800b8f4  0000b8fc  2**0
                  CONTENTS
  4 .ARM          00000000  0800b8f4  0800b8f4  0000b8fc  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800b8f4  0800b8fc  0000b8fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800b8f4  0800b8f4  0000b8f4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800b8f8  0800b8f8  0000b8f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000000  20000000  20000000  0000b8fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000024  20000000  0800b8fc  00010000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20000024  0800b8fc  00010024  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  0000b8fc  2**0
                  CONTENTS, READONLY
 12 .debug_info   00000bc6  00000000  00000000  0000b925  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000052b  00000000  00000000  0000c4eb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000198  00000000  00000000  0000ca18  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000130  00000000  00000000  0000cbb0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00000ee8  00000000  00000000  0000cce0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00000a89  00000000  00000000  0000dbc8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00003c11  00000000  00000000  0000e651  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  00012262  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000494  00000000  00000000  000122b4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08001130 <__do_global_dtors_aux>:
 8001130:	b510      	push	{r4, lr}
 8001132:	4c05      	ldr	r4, [pc, #20]	; (8001148 <__do_global_dtors_aux+0x18>)
 8001134:	7823      	ldrb	r3, [r4, #0]
 8001136:	b933      	cbnz	r3, 8001146 <__do_global_dtors_aux+0x16>
 8001138:	4b04      	ldr	r3, [pc, #16]	; (800114c <__do_global_dtors_aux+0x1c>)
 800113a:	b113      	cbz	r3, 8001142 <__do_global_dtors_aux+0x12>
 800113c:	4804      	ldr	r0, [pc, #16]	; (8001150 <__do_global_dtors_aux+0x20>)
 800113e:	f3af 8000 	nop.w
 8001142:	2301      	movs	r3, #1
 8001144:	7023      	strb	r3, [r4, #0]
 8001146:	bd10      	pop	{r4, pc}
 8001148:	20000000 	.word	0x20000000
 800114c:	00000000 	.word	0x00000000
 8001150:	080018dc 	.word	0x080018dc

08001154 <frame_dummy>:
 8001154:	b508      	push	{r3, lr}
 8001156:	4b03      	ldr	r3, [pc, #12]	; (8001164 <frame_dummy+0x10>)
 8001158:	b11b      	cbz	r3, 8001162 <frame_dummy+0xe>
 800115a:	4903      	ldr	r1, [pc, #12]	; (8001168 <frame_dummy+0x14>)
 800115c:	4803      	ldr	r0, [pc, #12]	; (800116c <frame_dummy+0x18>)
 800115e:	f3af 8000 	nop.w
 8001162:	bd08      	pop	{r3, pc}
 8001164:	00000000 	.word	0x00000000
 8001168:	20000004 	.word	0x20000004
 800116c:	080018dc 	.word	0x080018dc

08001170 <MGPIO_VidSetPinDirection>:

#include "DIO_interface.h"
#include "DIO_private.h"
#include "DIO_config.h"

void MGPIO_VidSetPinDirection( u8 Copy_u8Port , u8 Copy_u8Pin , u8 u8Copy_u8Mode ){
 8001170:	b480      	push	{r7}
 8001172:	b083      	sub	sp, #12
 8001174:	af00      	add	r7, sp, #0
 8001176:	4603      	mov	r3, r0
 8001178:	71fb      	strb	r3, [r7, #7]
 800117a:	460b      	mov	r3, r1
 800117c:	71bb      	strb	r3, [r7, #6]
 800117e:	4613      	mov	r3, r2
 8001180:	717b      	strb	r3, [r7, #5]

	switch(Copy_u8Port)
 8001182:	79fb      	ldrb	r3, [r7, #7]
 8001184:	2b02      	cmp	r3, #2
 8001186:	d07a      	beq.n	800127e <MGPIO_VidSetPinDirection+0x10e>
 8001188:	2b02      	cmp	r3, #2
 800118a:	f300 80b1 	bgt.w	80012f0 <MGPIO_VidSetPinDirection+0x180>
 800118e:	2b00      	cmp	r3, #0
 8001190:	d002      	beq.n	8001198 <MGPIO_VidSetPinDirection+0x28>
 8001192:	2b01      	cmp	r3, #1
 8001194:	d03a      	beq.n	800120c <MGPIO_VidSetPinDirection+0x9c>
			Copy_u8Pin = Copy_u8Pin - 8;
			GPIOC_CRH &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ) );
			GPIOC_CRH |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 )  ;
		}
		break;
	default :break;
 8001196:	e0ab      	b.n	80012f0 <MGPIO_VidSetPinDirection+0x180>
		if(Copy_u8Pin <= 7 )
 8001198:	79bb      	ldrb	r3, [r7, #6]
 800119a:	2b07      	cmp	r3, #7
 800119c:	d817      	bhi.n	80011ce <MGPIO_VidSetPinDirection+0x5e>
			GPIOA_CRL &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ));// R M W
 800119e:	4b5a      	ldr	r3, [pc, #360]	; (8001308 <MGPIO_VidSetPinDirection+0x198>)
 80011a0:	681b      	ldr	r3, [r3, #0]
 80011a2:	79ba      	ldrb	r2, [r7, #6]
 80011a4:	0092      	lsls	r2, r2, #2
 80011a6:	210f      	movs	r1, #15
 80011a8:	fa01 f202 	lsl.w	r2, r1, r2
 80011ac:	43d2      	mvns	r2, r2
 80011ae:	4611      	mov	r1, r2
 80011b0:	4a55      	ldr	r2, [pc, #340]	; (8001308 <MGPIO_VidSetPinDirection+0x198>)
 80011b2:	400b      	ands	r3, r1
 80011b4:	6013      	str	r3, [r2, #0]
			GPIOA_CRL |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 );
 80011b6:	4b54      	ldr	r3, [pc, #336]	; (8001308 <MGPIO_VidSetPinDirection+0x198>)
 80011b8:	681b      	ldr	r3, [r3, #0]
 80011ba:	7979      	ldrb	r1, [r7, #5]
 80011bc:	79ba      	ldrb	r2, [r7, #6]
 80011be:	0092      	lsls	r2, r2, #2
 80011c0:	fa01 f202 	lsl.w	r2, r1, r2
 80011c4:	4611      	mov	r1, r2
 80011c6:	4a50      	ldr	r2, [pc, #320]	; (8001308 <MGPIO_VidSetPinDirection+0x198>)
 80011c8:	430b      	orrs	r3, r1
 80011ca:	6013      	str	r3, [r2, #0]
		break;
 80011cc:	e092      	b.n	80012f4 <MGPIO_VidSetPinDirection+0x184>
		else if(Copy_u8Pin <=15 )
 80011ce:	79bb      	ldrb	r3, [r7, #6]
 80011d0:	2b0f      	cmp	r3, #15
 80011d2:	f200 808f 	bhi.w	80012f4 <MGPIO_VidSetPinDirection+0x184>
			Copy_u8Pin = Copy_u8Pin - 8;
 80011d6:	79bb      	ldrb	r3, [r7, #6]
 80011d8:	3b08      	subs	r3, #8
 80011da:	71bb      	strb	r3, [r7, #6]
			GPIOA_CRH &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ) );
 80011dc:	4b4b      	ldr	r3, [pc, #300]	; (800130c <MGPIO_VidSetPinDirection+0x19c>)
 80011de:	681b      	ldr	r3, [r3, #0]
 80011e0:	79ba      	ldrb	r2, [r7, #6]
 80011e2:	0092      	lsls	r2, r2, #2
 80011e4:	210f      	movs	r1, #15
 80011e6:	fa01 f202 	lsl.w	r2, r1, r2
 80011ea:	43d2      	mvns	r2, r2
 80011ec:	4611      	mov	r1, r2
 80011ee:	4a47      	ldr	r2, [pc, #284]	; (800130c <MGPIO_VidSetPinDirection+0x19c>)
 80011f0:	400b      	ands	r3, r1
 80011f2:	6013      	str	r3, [r2, #0]
			GPIOA_CRH |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 );
 80011f4:	4b45      	ldr	r3, [pc, #276]	; (800130c <MGPIO_VidSetPinDirection+0x19c>)
 80011f6:	681b      	ldr	r3, [r3, #0]
 80011f8:	7979      	ldrb	r1, [r7, #5]
 80011fa:	79ba      	ldrb	r2, [r7, #6]
 80011fc:	0092      	lsls	r2, r2, #2
 80011fe:	fa01 f202 	lsl.w	r2, r1, r2
 8001202:	4611      	mov	r1, r2
 8001204:	4a41      	ldr	r2, [pc, #260]	; (800130c <MGPIO_VidSetPinDirection+0x19c>)
 8001206:	430b      	orrs	r3, r1
 8001208:	6013      	str	r3, [r2, #0]
		break;
 800120a:	e073      	b.n	80012f4 <MGPIO_VidSetPinDirection+0x184>
		if(Copy_u8Pin <= 7 )
 800120c:	79bb      	ldrb	r3, [r7, #6]
 800120e:	2b07      	cmp	r3, #7
 8001210:	d817      	bhi.n	8001242 <MGPIO_VidSetPinDirection+0xd2>
			GPIOB_CRL &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ) );// R M W
 8001212:	4b3f      	ldr	r3, [pc, #252]	; (8001310 <MGPIO_VidSetPinDirection+0x1a0>)
 8001214:	681b      	ldr	r3, [r3, #0]
 8001216:	79ba      	ldrb	r2, [r7, #6]
 8001218:	0092      	lsls	r2, r2, #2
 800121a:	210f      	movs	r1, #15
 800121c:	fa01 f202 	lsl.w	r2, r1, r2
 8001220:	43d2      	mvns	r2, r2
 8001222:	4611      	mov	r1, r2
 8001224:	4a3a      	ldr	r2, [pc, #232]	; (8001310 <MGPIO_VidSetPinDirection+0x1a0>)
 8001226:	400b      	ands	r3, r1
 8001228:	6013      	str	r3, [r2, #0]
			GPIOB_CRL |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 )  ;
 800122a:	4b39      	ldr	r3, [pc, #228]	; (8001310 <MGPIO_VidSetPinDirection+0x1a0>)
 800122c:	681b      	ldr	r3, [r3, #0]
 800122e:	7979      	ldrb	r1, [r7, #5]
 8001230:	79ba      	ldrb	r2, [r7, #6]
 8001232:	0092      	lsls	r2, r2, #2
 8001234:	fa01 f202 	lsl.w	r2, r1, r2
 8001238:	4611      	mov	r1, r2
 800123a:	4a35      	ldr	r2, [pc, #212]	; (8001310 <MGPIO_VidSetPinDirection+0x1a0>)
 800123c:	430b      	orrs	r3, r1
 800123e:	6013      	str	r3, [r2, #0]
		break;
 8001240:	e05a      	b.n	80012f8 <MGPIO_VidSetPinDirection+0x188>
		else if(Copy_u8Pin <=15 )
 8001242:	79bb      	ldrb	r3, [r7, #6]
 8001244:	2b0f      	cmp	r3, #15
 8001246:	d857      	bhi.n	80012f8 <MGPIO_VidSetPinDirection+0x188>
			Copy_u8Pin = Copy_u8Pin - 8;
 8001248:	79bb      	ldrb	r3, [r7, #6]
 800124a:	3b08      	subs	r3, #8
 800124c:	71bb      	strb	r3, [r7, #6]
			GPIOB_CRH &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ) );
 800124e:	4b31      	ldr	r3, [pc, #196]	; (8001314 <MGPIO_VidSetPinDirection+0x1a4>)
 8001250:	681b      	ldr	r3, [r3, #0]
 8001252:	79ba      	ldrb	r2, [r7, #6]
 8001254:	0092      	lsls	r2, r2, #2
 8001256:	210f      	movs	r1, #15
 8001258:	fa01 f202 	lsl.w	r2, r1, r2
 800125c:	43d2      	mvns	r2, r2
 800125e:	4611      	mov	r1, r2
 8001260:	4a2c      	ldr	r2, [pc, #176]	; (8001314 <MGPIO_VidSetPinDirection+0x1a4>)
 8001262:	400b      	ands	r3, r1
 8001264:	6013      	str	r3, [r2, #0]
			GPIOB_CRH |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 )  ;
 8001266:	4b2b      	ldr	r3, [pc, #172]	; (8001314 <MGPIO_VidSetPinDirection+0x1a4>)
 8001268:	681b      	ldr	r3, [r3, #0]
 800126a:	7979      	ldrb	r1, [r7, #5]
 800126c:	79ba      	ldrb	r2, [r7, #6]
 800126e:	0092      	lsls	r2, r2, #2
 8001270:	fa01 f202 	lsl.w	r2, r1, r2
 8001274:	4611      	mov	r1, r2
 8001276:	4a27      	ldr	r2, [pc, #156]	; (8001314 <MGPIO_VidSetPinDirection+0x1a4>)
 8001278:	430b      	orrs	r3, r1
 800127a:	6013      	str	r3, [r2, #0]
		break;
 800127c:	e03c      	b.n	80012f8 <MGPIO_VidSetPinDirection+0x188>
		if(Copy_u8Pin <= 7 )
 800127e:	79bb      	ldrb	r3, [r7, #6]
 8001280:	2b07      	cmp	r3, #7
 8001282:	d817      	bhi.n	80012b4 <MGPIO_VidSetPinDirection+0x144>
			GPIOC_CRL &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ) );// R M W
 8001284:	4b24      	ldr	r3, [pc, #144]	; (8001318 <MGPIO_VidSetPinDirection+0x1a8>)
 8001286:	681b      	ldr	r3, [r3, #0]
 8001288:	79ba      	ldrb	r2, [r7, #6]
 800128a:	0092      	lsls	r2, r2, #2
 800128c:	210f      	movs	r1, #15
 800128e:	fa01 f202 	lsl.w	r2, r1, r2
 8001292:	43d2      	mvns	r2, r2
 8001294:	4611      	mov	r1, r2
 8001296:	4a20      	ldr	r2, [pc, #128]	; (8001318 <MGPIO_VidSetPinDirection+0x1a8>)
 8001298:	400b      	ands	r3, r1
 800129a:	6013      	str	r3, [r2, #0]
			GPIOC_CRL |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 )  ;
 800129c:	4b1e      	ldr	r3, [pc, #120]	; (8001318 <MGPIO_VidSetPinDirection+0x1a8>)
 800129e:	681b      	ldr	r3, [r3, #0]
 80012a0:	7979      	ldrb	r1, [r7, #5]
 80012a2:	79ba      	ldrb	r2, [r7, #6]
 80012a4:	0092      	lsls	r2, r2, #2
 80012a6:	fa01 f202 	lsl.w	r2, r1, r2
 80012aa:	4611      	mov	r1, r2
 80012ac:	4a1a      	ldr	r2, [pc, #104]	; (8001318 <MGPIO_VidSetPinDirection+0x1a8>)
 80012ae:	430b      	orrs	r3, r1
 80012b0:	6013      	str	r3, [r2, #0]
		break;
 80012b2:	e023      	b.n	80012fc <MGPIO_VidSetPinDirection+0x18c>
		else if(Copy_u8Pin <=15 )
 80012b4:	79bb      	ldrb	r3, [r7, #6]
 80012b6:	2b0f      	cmp	r3, #15
 80012b8:	d820      	bhi.n	80012fc <MGPIO_VidSetPinDirection+0x18c>
			Copy_u8Pin = Copy_u8Pin - 8;
 80012ba:	79bb      	ldrb	r3, [r7, #6]
 80012bc:	3b08      	subs	r3, #8
 80012be:	71bb      	strb	r3, [r7, #6]
			GPIOC_CRH &= ~ ( ( 0b1111 )    << ( Copy_u8Pin * 4 ) );
 80012c0:	4b16      	ldr	r3, [pc, #88]	; (800131c <MGPIO_VidSetPinDirection+0x1ac>)
 80012c2:	681b      	ldr	r3, [r3, #0]
 80012c4:	79ba      	ldrb	r2, [r7, #6]
 80012c6:	0092      	lsls	r2, r2, #2
 80012c8:	210f      	movs	r1, #15
 80012ca:	fa01 f202 	lsl.w	r2, r1, r2
 80012ce:	43d2      	mvns	r2, r2
 80012d0:	4611      	mov	r1, r2
 80012d2:	4a12      	ldr	r2, [pc, #72]	; (800131c <MGPIO_VidSetPinDirection+0x1ac>)
 80012d4:	400b      	ands	r3, r1
 80012d6:	6013      	str	r3, [r2, #0]
			GPIOC_CRH |= ( u8Copy_u8Mode ) << ( Copy_u8Pin * 4 )  ;
 80012d8:	4b10      	ldr	r3, [pc, #64]	; (800131c <MGPIO_VidSetPinDirection+0x1ac>)
 80012da:	681b      	ldr	r3, [r3, #0]
 80012dc:	7979      	ldrb	r1, [r7, #5]
 80012de:	79ba      	ldrb	r2, [r7, #6]
 80012e0:	0092      	lsls	r2, r2, #2
 80012e2:	fa01 f202 	lsl.w	r2, r1, r2
 80012e6:	4611      	mov	r1, r2
 80012e8:	4a0c      	ldr	r2, [pc, #48]	; (800131c <MGPIO_VidSetPinDirection+0x1ac>)
 80012ea:	430b      	orrs	r3, r1
 80012ec:	6013      	str	r3, [r2, #0]
		break;
 80012ee:	e005      	b.n	80012fc <MGPIO_VidSetPinDirection+0x18c>
	default :break;
 80012f0:	bf00      	nop
 80012f2:	e004      	b.n	80012fe <MGPIO_VidSetPinDirection+0x18e>
		break;
 80012f4:	bf00      	nop
 80012f6:	e002      	b.n	80012fe <MGPIO_VidSetPinDirection+0x18e>
		break;
 80012f8:	bf00      	nop
 80012fa:	e000      	b.n	80012fe <MGPIO_VidSetPinDirection+0x18e>
		break;
 80012fc:	bf00      	nop
	}


}
 80012fe:	bf00      	nop
 8001300:	370c      	adds	r7, #12
 8001302:	46bd      	mov	sp, r7
 8001304:	bc80      	pop	{r7}
 8001306:	4770      	bx	lr
 8001308:	40010800 	.word	0x40010800
 800130c:	40010804 	.word	0x40010804
 8001310:	40010c00 	.word	0x40010c00
 8001314:	40010c04 	.word	0x40010c04
 8001318:	40011000 	.word	0x40011000
 800131c:	40011004 	.word	0x40011004

08001320 <MGPIO_VidSetPinValue>:

void MGPIO_VidSetPinValue( u8 Copy_u8Port , u8 Copy_u8Pin , u8 u8Copy_u8Value ){
 8001320:	b480      	push	{r7}
 8001322:	b083      	sub	sp, #12
 8001324:	af00      	add	r7, sp, #0
 8001326:	4603      	mov	r3, r0
 8001328:	71fb      	strb	r3, [r7, #7]
 800132a:	460b      	mov	r3, r1
 800132c:	71bb      	strb	r3, [r7, #6]
 800132e:	4613      	mov	r3, r2
 8001330:	717b      	strb	r3, [r7, #5]

	switch(Copy_u8Port)
 8001332:	79fb      	ldrb	r3, [r7, #7]
 8001334:	2b02      	cmp	r3, #2
 8001336:	d040      	beq.n	80013ba <MGPIO_VidSetPinValue+0x9a>
 8001338:	2b02      	cmp	r3, #2
 800133a:	dc60      	bgt.n	80013fe <MGPIO_VidSetPinValue+0xde>
 800133c:	2b00      	cmp	r3, #0
 800133e:	d002      	beq.n	8001346 <MGPIO_VidSetPinValue+0x26>
 8001340:	2b01      	cmp	r3, #1
 8001342:	d01d      	beq.n	8001380 <MGPIO_VidSetPinValue+0x60>
		}
		break;

	}

}
 8001344:	e05b      	b.n	80013fe <MGPIO_VidSetPinValue+0xde>
		if( u8Copy_u8Value == HIGH ){
 8001346:	797b      	ldrb	r3, [r7, #5]
 8001348:	2b01      	cmp	r3, #1
 800134a:	d10a      	bne.n	8001362 <MGPIO_VidSetPinValue+0x42>
			SET_BIT( GPIOA_ODR , Copy_u8Pin );
 800134c:	4b2e      	ldr	r3, [pc, #184]	; (8001408 <MGPIO_VidSetPinValue+0xe8>)
 800134e:	681b      	ldr	r3, [r3, #0]
 8001350:	79ba      	ldrb	r2, [r7, #6]
 8001352:	2101      	movs	r1, #1
 8001354:	fa01 f202 	lsl.w	r2, r1, r2
 8001358:	4611      	mov	r1, r2
 800135a:	4a2b      	ldr	r2, [pc, #172]	; (8001408 <MGPIO_VidSetPinValue+0xe8>)
 800135c:	430b      	orrs	r3, r1
 800135e:	6013      	str	r3, [r2, #0]
		break;
 8001360:	e048      	b.n	80013f4 <MGPIO_VidSetPinValue+0xd4>
		}else if( u8Copy_u8Value == LOW ){
 8001362:	797b      	ldrb	r3, [r7, #5]
 8001364:	2b00      	cmp	r3, #0
 8001366:	d145      	bne.n	80013f4 <MGPIO_VidSetPinValue+0xd4>
			CLR_BIT(  GPIOA_ODR , Copy_u8Pin );
 8001368:	4b27      	ldr	r3, [pc, #156]	; (8001408 <MGPIO_VidSetPinValue+0xe8>)
 800136a:	681b      	ldr	r3, [r3, #0]
 800136c:	79ba      	ldrb	r2, [r7, #6]
 800136e:	2101      	movs	r1, #1
 8001370:	fa01 f202 	lsl.w	r2, r1, r2
 8001374:	43d2      	mvns	r2, r2
 8001376:	4611      	mov	r1, r2
 8001378:	4a23      	ldr	r2, [pc, #140]	; (8001408 <MGPIO_VidSetPinValue+0xe8>)
 800137a:	400b      	ands	r3, r1
 800137c:	6013      	str	r3, [r2, #0]
		break;
 800137e:	e039      	b.n	80013f4 <MGPIO_VidSetPinValue+0xd4>
		if( u8Copy_u8Value == HIGH ){
 8001380:	797b      	ldrb	r3, [r7, #5]
 8001382:	2b01      	cmp	r3, #1
 8001384:	d10a      	bne.n	800139c <MGPIO_VidSetPinValue+0x7c>
			SET_BIT( GPIOB_ODR  , Copy_u8Pin );
 8001386:	4b21      	ldr	r3, [pc, #132]	; (800140c <MGPIO_VidSetPinValue+0xec>)
 8001388:	681b      	ldr	r3, [r3, #0]
 800138a:	79ba      	ldrb	r2, [r7, #6]
 800138c:	2101      	movs	r1, #1
 800138e:	fa01 f202 	lsl.w	r2, r1, r2
 8001392:	4611      	mov	r1, r2
 8001394:	4a1d      	ldr	r2, [pc, #116]	; (800140c <MGPIO_VidSetPinValue+0xec>)
 8001396:	430b      	orrs	r3, r1
 8001398:	6013      	str	r3, [r2, #0]
		break;
 800139a:	e02d      	b.n	80013f8 <MGPIO_VidSetPinValue+0xd8>
		}else if( u8Copy_u8Value == LOW ){
 800139c:	797b      	ldrb	r3, [r7, #5]
 800139e:	2b00      	cmp	r3, #0
 80013a0:	d12a      	bne.n	80013f8 <MGPIO_VidSetPinValue+0xd8>
			CLR_BIT( GPIOB_ODR  , Copy_u8Pin );
 80013a2:	4b1a      	ldr	r3, [pc, #104]	; (800140c <MGPIO_VidSetPinValue+0xec>)
 80013a4:	681b      	ldr	r3, [r3, #0]
 80013a6:	79ba      	ldrb	r2, [r7, #6]
 80013a8:	2101      	movs	r1, #1
 80013aa:	fa01 f202 	lsl.w	r2, r1, r2
 80013ae:	43d2      	mvns	r2, r2
 80013b0:	4611      	mov	r1, r2
 80013b2:	4a16      	ldr	r2, [pc, #88]	; (800140c <MGPIO_VidSetPinValue+0xec>)
 80013b4:	400b      	ands	r3, r1
 80013b6:	6013      	str	r3, [r2, #0]
		break;
 80013b8:	e01e      	b.n	80013f8 <MGPIO_VidSetPinValue+0xd8>
		if( u8Copy_u8Value == HIGH ){
 80013ba:	797b      	ldrb	r3, [r7, #5]
 80013bc:	2b01      	cmp	r3, #1
 80013be:	d10a      	bne.n	80013d6 <MGPIO_VidSetPinValue+0xb6>
			SET_BIT( GPIOC_ODR , Copy_u8Pin );
 80013c0:	4b13      	ldr	r3, [pc, #76]	; (8001410 <MGPIO_VidSetPinValue+0xf0>)
 80013c2:	681b      	ldr	r3, [r3, #0]
 80013c4:	79ba      	ldrb	r2, [r7, #6]
 80013c6:	2101      	movs	r1, #1
 80013c8:	fa01 f202 	lsl.w	r2, r1, r2
 80013cc:	4611      	mov	r1, r2
 80013ce:	4a10      	ldr	r2, [pc, #64]	; (8001410 <MGPIO_VidSetPinValue+0xf0>)
 80013d0:	430b      	orrs	r3, r1
 80013d2:	6013      	str	r3, [r2, #0]
		break;
 80013d4:	e012      	b.n	80013fc <MGPIO_VidSetPinValue+0xdc>
		}else if( u8Copy_u8Value == LOW ){
 80013d6:	797b      	ldrb	r3, [r7, #5]
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d10f      	bne.n	80013fc <MGPIO_VidSetPinValue+0xdc>
			CLR_BIT( GPIOC_ODR , Copy_u8Pin );
 80013dc:	4b0c      	ldr	r3, [pc, #48]	; (8001410 <MGPIO_VidSetPinValue+0xf0>)
 80013de:	681b      	ldr	r3, [r3, #0]
 80013e0:	79ba      	ldrb	r2, [r7, #6]
 80013e2:	2101      	movs	r1, #1
 80013e4:	fa01 f202 	lsl.w	r2, r1, r2
 80013e8:	43d2      	mvns	r2, r2
 80013ea:	4611      	mov	r1, r2
 80013ec:	4a08      	ldr	r2, [pc, #32]	; (8001410 <MGPIO_VidSetPinValue+0xf0>)
 80013ee:	400b      	ands	r3, r1
 80013f0:	6013      	str	r3, [r2, #0]
		break;
 80013f2:	e003      	b.n	80013fc <MGPIO_VidSetPinValue+0xdc>
		break;
 80013f4:	bf00      	nop
 80013f6:	e002      	b.n	80013fe <MGPIO_VidSetPinValue+0xde>
		break;
 80013f8:	bf00      	nop
 80013fa:	e000      	b.n	80013fe <MGPIO_VidSetPinValue+0xde>
		break;
 80013fc:	bf00      	nop
}
 80013fe:	bf00      	nop
 8001400:	370c      	adds	r7, #12
 8001402:	46bd      	mov	sp, r7
 8001404:	bc80      	pop	{r7}
 8001406:	4770      	bx	lr
 8001408:	4001080c 	.word	0x4001080c
 800140c:	40010c0c 	.word	0x40010c0c
 8001410:	4001100c 	.word	0x4001100c

08001414 <MSPI1_voidInit>:
#include "MSPI_private.h"

void (*CallBack)(u8);

void MSPI1_voidInit(void)
{
 8001414:	b480      	push	{r7}
 8001416:	af00      	add	r7, sp, #0
	MSPI1->CR1 = 0x0347;
 8001418:	4b03      	ldr	r3, [pc, #12]	; (8001428 <MSPI1_voidInit+0x14>)
 800141a:	f240 3247 	movw	r2, #839	; 0x347
 800141e:	601a      	str	r2, [r3, #0]
}
 8001420:	bf00      	nop
 8001422:	46bd      	mov	sp, r7
 8001424:	bc80      	pop	{r7}
 8001426:	4770      	bx	lr
 8001428:	40013000 	.word	0x40013000

0800142c <MSPI1_voidSendReceiveSynch>:

void MSPI1_voidSendReceiveSynch(u8 Copy_u8DataToTransmit, u8 *Copy_DataToReceive)
{
 800142c:	b580      	push	{r7, lr}
 800142e:	b082      	sub	sp, #8
 8001430:	af00      	add	r7, sp, #0
 8001432:	4603      	mov	r3, r0
 8001434:	6039      	str	r1, [r7, #0]
 8001436:	71fb      	strb	r3, [r7, #7]
	/* Clear For Slave Select Pin */
	MGPIO_VidSetPinValue(MSPI1_SLAVE_PIN,LOW);
 8001438:	2200      	movs	r2, #0
 800143a:	2100      	movs	r1, #0
 800143c:	2000      	movs	r0, #0
 800143e:	f7ff ff6f 	bl	8001320 <MGPIO_VidSetPinValue>
	/* cause it active low */
	
	/* Send Data */
	MSPI1 -> DR = Copy_u8DataToTransmit;
 8001442:	4a0c      	ldr	r2, [pc, #48]	; (8001474 <MSPI1_voidSendReceiveSynch+0x48>)
 8001444:	79fb      	ldrb	r3, [r7, #7]
 8001446:	60d3      	str	r3, [r2, #12]
	
	/* Wait Busy Flag to finish */
	while (GET_BIT(MSPI1 -> SR, 7) == 1);
 8001448:	bf00      	nop
 800144a:	4b0a      	ldr	r3, [pc, #40]	; (8001474 <MSPI1_voidSendReceiveSynch+0x48>)
 800144c:	689b      	ldr	r3, [r3, #8]
 800144e:	09db      	lsrs	r3, r3, #7
 8001450:	f003 0301 	and.w	r3, r3, #1
 8001454:	2b01      	cmp	r3, #1
 8001456:	d0f8      	beq.n	800144a <MSPI1_voidSendReceiveSynch+0x1e>

 	/* Return to the received data */
	*Copy_DataToReceive = MSPI1 -> DR;
 8001458:	4b06      	ldr	r3, [pc, #24]	; (8001474 <MSPI1_voidSendReceiveSynch+0x48>)
 800145a:	68db      	ldr	r3, [r3, #12]
 800145c:	b2da      	uxtb	r2, r3
 800145e:	683b      	ldr	r3, [r7, #0]
 8001460:	701a      	strb	r2, [r3, #0]
	
	/* Set Salve Select Pin */
	MGPIO_VidSetPinValue(MSPI1_SLAVE_PIN,HIGH);
 8001462:	2201      	movs	r2, #1
 8001464:	2100      	movs	r1, #0
 8001466:	2000      	movs	r0, #0
 8001468:	f7ff ff5a 	bl	8001320 <MGPIO_VidSetPinValue>
}
 800146c:	bf00      	nop
 800146e:	3708      	adds	r7, #8
 8001470:	46bd      	mov	sp, r7
 8001472:	bd80      	pop	{r7, pc}
 8001474:	40013000 	.word	0x40013000

08001478 <RCC_voidInitSysClock>:
#include "RCC_interface.h"
#include "RCC_private.h"
#include "RCC_config.h"

void RCC_voidInitSysClock(void)
{
 8001478:	b480      	push	{r7}
 800147a:	af00      	add	r7, sp, #0
	#elif   RCC_CLOCK_TYPE == RCC_HSE_RC
		RCC_CR   = 0x00050000; /* Enable HSE with bypass */
		RCC_CFGR = 0x00000001;
		
	#elif   RCC_CLOCK_TYPE == RCC_HSI
		RCC_CR   = 0x00000081; /* Enable HSI + Trimming = 0 */
 800147c:	4b04      	ldr	r3, [pc, #16]	; (8001490 <RCC_voidInitSysClock+0x18>)
 800147e:	2281      	movs	r2, #129	; 0x81
 8001480:	601a      	str	r2, [r3, #0]
		RCC_CFGR = 0x00000000;
 8001482:	4b04      	ldr	r3, [pc, #16]	; (8001494 <RCC_voidInitSysClock+0x1c>)
 8001484:	2200      	movs	r2, #0
 8001486:	601a      	str	r2, [r3, #0]
		#endif
	
	#else
		#error("You chosed Wrong Clock type")
	#endif
}
 8001488:	bf00      	nop
 800148a:	46bd      	mov	sp, r7
 800148c:	bc80      	pop	{r7}
 800148e:	4770      	bx	lr
 8001490:	40021000 	.word	0x40021000
 8001494:	40021004 	.word	0x40021004

08001498 <RCC_voidEnableClock>:



void RCC_voidEnableClock(u8 Copy_u8BusId, u8 Copy_u8PerId)
{
 8001498:	b480      	push	{r7}
 800149a:	b083      	sub	sp, #12
 800149c:	af00      	add	r7, sp, #0
 800149e:	4603      	mov	r3, r0
 80014a0:	460a      	mov	r2, r1
 80014a2:	71fb      	strb	r3, [r7, #7]
 80014a4:	4613      	mov	r3, r2
 80014a6:	71bb      	strb	r3, [r7, #6]
	if (Copy_u8PerId <= 31)
 80014a8:	79bb      	ldrb	r3, [r7, #6]
 80014aa:	2b1f      	cmp	r3, #31
 80014ac:	d82a      	bhi.n	8001504 <RCC_voidEnableClock+0x6c>
	{
		switch (Copy_u8BusId)
 80014ae:	79fb      	ldrb	r3, [r7, #7]
 80014b0:	2b02      	cmp	r3, #2
 80014b2:	d01c      	beq.n	80014ee <RCC_voidEnableClock+0x56>
 80014b4:	2b02      	cmp	r3, #2
 80014b6:	dc25      	bgt.n	8001504 <RCC_voidEnableClock+0x6c>
 80014b8:	2b00      	cmp	r3, #0
 80014ba:	d002      	beq.n	80014c2 <RCC_voidEnableClock+0x2a>
 80014bc:	2b01      	cmp	r3, #1
 80014be:	d00b      	beq.n	80014d8 <RCC_voidEnableClock+0x40>
	else
	{
		/* Return Error */
	}

}
 80014c0:	e020      	b.n	8001504 <RCC_voidEnableClock+0x6c>
			case RCC_AHB  : SET_BIT(RCC_AHBENR  ,Copy_u8PerId);   break;
 80014c2:	4b13      	ldr	r3, [pc, #76]	; (8001510 <RCC_voidEnableClock+0x78>)
 80014c4:	681b      	ldr	r3, [r3, #0]
 80014c6:	79ba      	ldrb	r2, [r7, #6]
 80014c8:	2101      	movs	r1, #1
 80014ca:	fa01 f202 	lsl.w	r2, r1, r2
 80014ce:	4611      	mov	r1, r2
 80014d0:	4a0f      	ldr	r2, [pc, #60]	; (8001510 <RCC_voidEnableClock+0x78>)
 80014d2:	430b      	orrs	r3, r1
 80014d4:	6013      	str	r3, [r2, #0]
 80014d6:	e015      	b.n	8001504 <RCC_voidEnableClock+0x6c>
			case RCC_APB1 : SET_BIT(RCC_APB1ENR ,Copy_u8PerId);   break;
 80014d8:	4b0e      	ldr	r3, [pc, #56]	; (8001514 <RCC_voidEnableClock+0x7c>)
 80014da:	681b      	ldr	r3, [r3, #0]
 80014dc:	79ba      	ldrb	r2, [r7, #6]
 80014de:	2101      	movs	r1, #1
 80014e0:	fa01 f202 	lsl.w	r2, r1, r2
 80014e4:	4611      	mov	r1, r2
 80014e6:	4a0b      	ldr	r2, [pc, #44]	; (8001514 <RCC_voidEnableClock+0x7c>)
 80014e8:	430b      	orrs	r3, r1
 80014ea:	6013      	str	r3, [r2, #0]
 80014ec:	e00a      	b.n	8001504 <RCC_voidEnableClock+0x6c>
			case RCC_APB2 : SET_BIT(RCC_APB2ENR ,Copy_u8PerId);   break;
 80014ee:	4b0a      	ldr	r3, [pc, #40]	; (8001518 <RCC_voidEnableClock+0x80>)
 80014f0:	681b      	ldr	r3, [r3, #0]
 80014f2:	79ba      	ldrb	r2, [r7, #6]
 80014f4:	2101      	movs	r1, #1
 80014f6:	fa01 f202 	lsl.w	r2, r1, r2
 80014fa:	4611      	mov	r1, r2
 80014fc:	4a06      	ldr	r2, [pc, #24]	; (8001518 <RCC_voidEnableClock+0x80>)
 80014fe:	430b      	orrs	r3, r1
 8001500:	6013      	str	r3, [r2, #0]
 8001502:	bf00      	nop
}
 8001504:	bf00      	nop
 8001506:	370c      	adds	r7, #12
 8001508:	46bd      	mov	sp, r7
 800150a:	bc80      	pop	{r7}
 800150c:	4770      	bx	lr
 800150e:	bf00      	nop
 8001510:	40021014 	.word	0x40021014
 8001514:	4002101c 	.word	0x4002101c
 8001518:	40021018 	.word	0x40021018

0800151c <MSTK_voidInit>:

/* Define Variable for interval mode */
static u8 MSTK_u8ModeOfInterval;

void MSTK_voidInit(void)
{
 800151c:	b480      	push	{r7}
 800151e:	af00      	add	r7, sp, #0
#if MSTK_CLK_SRC == MSTK_SRC_AHB
    /* Disable STK - Disable STK Interrupt - Set clock source AHB */
	MSTK -> CTRL = 0x00000004;
#else
    /* Disable STK - Disable STK Interrupt - Set clock source AHB/8 */
	MSTK -> CTRL = 0;
 8001520:	4b03      	ldr	r3, [pc, #12]	; (8001530 <MSTK_voidInit+0x14>)
 8001522:	2200      	movs	r2, #0
 8001524:	601a      	str	r2, [r3, #0]
	
#endif
}
 8001526:	bf00      	nop
 8001528:	46bd      	mov	sp, r7
 800152a:	bc80      	pop	{r7}
 800152c:	4770      	bx	lr
 800152e:	bf00      	nop
 8001530:	e000e010 	.word	0xe000e010

08001534 <MSTK_voidSetBusyWait>:

void MSTK_voidSetBusyWait( u32 Copy_u32Ticks )
{
 8001534:	b480      	push	{r7}
 8001536:	b083      	sub	sp, #12
 8001538:	af00      	add	r7, sp, #0
 800153a:	6078      	str	r0, [r7, #4]
	/* Load ticks to load register */
	MSTK -> LOAD = Copy_u32Ticks;
 800153c:	4a10      	ldr	r2, [pc, #64]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 800153e:	687b      	ldr	r3, [r7, #4]
 8001540:	6053      	str	r3, [r2, #4]
	
	/* Start Timer */
	SET_BIT(MSTK->CTRL, 0);
 8001542:	4b0f      	ldr	r3, [pc, #60]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 8001544:	681b      	ldr	r3, [r3, #0]
 8001546:	4a0e      	ldr	r2, [pc, #56]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 8001548:	f043 0301 	orr.w	r3, r3, #1
 800154c:	6013      	str	r3, [r2, #0]
	
	/* Wait till flag is raised */
	while( (GET_BIT(MSTK->CTRL,16)) == 0);
 800154e:	bf00      	nop
 8001550:	4b0b      	ldr	r3, [pc, #44]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 8001552:	681b      	ldr	r3, [r3, #0]
 8001554:	0c1b      	lsrs	r3, r3, #16
 8001556:	f003 0301 	and.w	r3, r3, #1
 800155a:	2b00      	cmp	r3, #0
 800155c:	d0f8      	beq.n	8001550 <MSTK_voidSetBusyWait+0x1c>
	
	/* Stop Timer */
	CLR_BIT(MSTK->CTRL, 0);
 800155e:	4b08      	ldr	r3, [pc, #32]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 8001560:	681b      	ldr	r3, [r3, #0]
 8001562:	4a07      	ldr	r2, [pc, #28]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 8001564:	f023 0301 	bic.w	r3, r3, #1
 8001568:	6013      	str	r3, [r2, #0]
	MSTK -> LOAD = 0;
 800156a:	4b05      	ldr	r3, [pc, #20]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 800156c:	2200      	movs	r2, #0
 800156e:	605a      	str	r2, [r3, #4]
	MSTK -> VAL  = 0;
 8001570:	4b03      	ldr	r3, [pc, #12]	; (8001580 <MSTK_voidSetBusyWait+0x4c>)
 8001572:	2200      	movs	r2, #0
 8001574:	609a      	str	r2, [r3, #8]
	
}
 8001576:	bf00      	nop
 8001578:	370c      	adds	r7, #12
 800157a:	46bd      	mov	sp, r7
 800157c:	bc80      	pop	{r7}
 800157e:	4770      	bx	lr
 8001580:	e000e010 	.word	0xe000e010

08001584 <SysTick_Handler>:
	
	return Local_u32RemainTime;
}

void SysTick_Handler(void)
{
 8001584:	b580      	push	{r7, lr}
 8001586:	b082      	sub	sp, #8
 8001588:	af00      	add	r7, sp, #0
	u8 Local_u8Temporary;

	if (MSTK_u8ModeOfInterval == MSTK_SINGLE_INTERVAL)
 800158a:	4b12      	ldr	r3, [pc, #72]	; (80015d4 <SysTick_Handler+0x50>)
 800158c:	781b      	ldrb	r3, [r3, #0]
 800158e:	2b00      	cmp	r3, #0
 8001590:	d111      	bne.n	80015b6 <SysTick_Handler+0x32>
	{
		/* Disable STK Interrupt */
		CLR_BIT(MSTK->CTRL, 1);
 8001592:	4b11      	ldr	r3, [pc, #68]	; (80015d8 <SysTick_Handler+0x54>)
 8001594:	681b      	ldr	r3, [r3, #0]
 8001596:	4a10      	ldr	r2, [pc, #64]	; (80015d8 <SysTick_Handler+0x54>)
 8001598:	f023 0302 	bic.w	r3, r3, #2
 800159c:	6013      	str	r3, [r2, #0]
	
		/* Stop Timer */
		SET_BIT(MSTK->CTRL, 0);
 800159e:	4b0e      	ldr	r3, [pc, #56]	; (80015d8 <SysTick_Handler+0x54>)
 80015a0:	681b      	ldr	r3, [r3, #0]
 80015a2:	4a0d      	ldr	r2, [pc, #52]	; (80015d8 <SysTick_Handler+0x54>)
 80015a4:	f043 0301 	orr.w	r3, r3, #1
 80015a8:	6013      	str	r3, [r2, #0]
		MSTK -> LOAD = 0;
 80015aa:	4b0b      	ldr	r3, [pc, #44]	; (80015d8 <SysTick_Handler+0x54>)
 80015ac:	2200      	movs	r2, #0
 80015ae:	605a      	str	r2, [r3, #4]
		MSTK -> VAL  = 0;
 80015b0:	4b09      	ldr	r3, [pc, #36]	; (80015d8 <SysTick_Handler+0x54>)
 80015b2:	2200      	movs	r2, #0
 80015b4:	609a      	str	r2, [r3, #8]
	}
	
	/* Callback notification */
	MSTK_CallBack();
 80015b6:	4b09      	ldr	r3, [pc, #36]	; (80015dc <SysTick_Handler+0x58>)
 80015b8:	681b      	ldr	r3, [r3, #0]
 80015ba:	4798      	blx	r3
	
	/* Clear interrupt flag */
	Local_u8Temporary = GET_BIT(MSTK->CTRL,16);
 80015bc:	4b06      	ldr	r3, [pc, #24]	; (80015d8 <SysTick_Handler+0x54>)
 80015be:	681b      	ldr	r3, [r3, #0]
 80015c0:	0c1b      	lsrs	r3, r3, #16
 80015c2:	b2db      	uxtb	r3, r3
 80015c4:	f003 0301 	and.w	r3, r3, #1
 80015c8:	71fb      	strb	r3, [r7, #7]
}
 80015ca:	bf00      	nop
 80015cc:	3708      	adds	r7, #8
 80015ce:	46bd      	mov	sp, r7
 80015d0:	bd80      	pop	{r7, pc}
 80015d2:	bf00      	nop
 80015d4:	20000020 	.word	0x20000020
 80015d8:	e000e010 	.word	0xe000e010
 80015dc:	2000001c 	.word	0x2000001c

080015e0 <HTFT_voidBounders>:
	/* write the low byte */
	voidWriteData(Color & 0x00FF);
}

static void HTFT_voidBounders(u8 x1, u8 x2, u8 y1, u8 y2)
{
 80015e0:	b590      	push	{r4, r7, lr}
 80015e2:	b083      	sub	sp, #12
 80015e4:	af00      	add	r7, sp, #0
 80015e6:	4604      	mov	r4, r0
 80015e8:	4608      	mov	r0, r1
 80015ea:	4611      	mov	r1, r2
 80015ec:	461a      	mov	r2, r3
 80015ee:	4623      	mov	r3, r4
 80015f0:	71fb      	strb	r3, [r7, #7]
 80015f2:	4603      	mov	r3, r0
 80015f4:	71bb      	strb	r3, [r7, #6]
 80015f6:	460b      	mov	r3, r1
 80015f8:	717b      	strb	r3, [r7, #5]
 80015fa:	4613      	mov	r3, r2
 80015fc:	713b      	strb	r3, [r7, #4]
	/* Set 'x' address */
	voidWriteCommand(0x2A);
 80015fe:	202a      	movs	r0, #42	; 0x2a
 8001600:	f000 f823 	bl	800164a <voidWriteCommand>
		/* area of working */
	/* start of 'x' */
	voidWriteData(0);
 8001604:	2000      	movs	r0, #0
 8001606:	f000 f835 	bl	8001674 <voidWriteData>
	voidWriteData(x1);
 800160a:	79fb      	ldrb	r3, [r7, #7]
 800160c:	4618      	mov	r0, r3
 800160e:	f000 f831 	bl	8001674 <voidWriteData>
	/* end of 'x' */
	voidWriteData(0);
 8001612:	2000      	movs	r0, #0
 8001614:	f000 f82e 	bl	8001674 <voidWriteData>
	voidWriteData(x2);
 8001618:	79bb      	ldrb	r3, [r7, #6]
 800161a:	4618      	mov	r0, r3
 800161c:	f000 f82a 	bl	8001674 <voidWriteData>

	/* Set 'y' address */
	voidWriteCommand(0x2B);
 8001620:	202b      	movs	r0, #43	; 0x2b
 8001622:	f000 f812 	bl	800164a <voidWriteCommand>
		/* area of working */
	/* start of 'y' */
	voidWriteData(0);
 8001626:	2000      	movs	r0, #0
 8001628:	f000 f824 	bl	8001674 <voidWriteData>
	voidWriteData(y1);
 800162c:	797b      	ldrb	r3, [r7, #5]
 800162e:	4618      	mov	r0, r3
 8001630:	f000 f820 	bl	8001674 <voidWriteData>
	/* end of 'y' */
	voidWriteData(0);
 8001634:	2000      	movs	r0, #0
 8001636:	f000 f81d 	bl	8001674 <voidWriteData>
	voidWriteData(y2);
 800163a:	793b      	ldrb	r3, [r7, #4]
 800163c:	4618      	mov	r0, r3
 800163e:	f000 f819 	bl	8001674 <voidWriteData>

}
 8001642:	bf00      	nop
 8001644:	370c      	adds	r7, #12
 8001646:	46bd      	mov	sp, r7
 8001648:	bd90      	pop	{r4, r7, pc}

0800164a <voidWriteCommand>:

static void voidWriteCommand(u8 Copy_u8Command)
{
 800164a:	b580      	push	{r7, lr}
 800164c:	b084      	sub	sp, #16
 800164e:	af00      	add	r7, sp, #0
 8001650:	4603      	mov	r3, r0
 8001652:	71fb      	strb	r3, [r7, #7]
	u8 Local_u8Temp;

	/* Set A0 pin to LOW */
	MGPIO_VidSetPinValue(TFT_A0_PIN,LOW);
 8001654:	2200      	movs	r2, #0
 8001656:	2102      	movs	r1, #2
 8001658:	2000      	movs	r0, #0
 800165a:	f7ff fe61 	bl	8001320 <MGPIO_VidSetPinValue>

	/* Send Command over SPI */
	MSPI1_voidSendReceiveSynch(Copy_u8Command,&Local_u8Temp);
 800165e:	f107 020f 	add.w	r2, r7, #15
 8001662:	79fb      	ldrb	r3, [r7, #7]
 8001664:	4611      	mov	r1, r2
 8001666:	4618      	mov	r0, r3
 8001668:	f7ff fee0 	bl	800142c <MSPI1_voidSendReceiveSynch>
}
 800166c:	bf00      	nop
 800166e:	3710      	adds	r7, #16
 8001670:	46bd      	mov	sp, r7
 8001672:	bd80      	pop	{r7, pc}

08001674 <voidWriteData>:

static void voidWriteData(u8 Copy_u8Data)
{
 8001674:	b580      	push	{r7, lr}
 8001676:	b084      	sub	sp, #16
 8001678:	af00      	add	r7, sp, #0
 800167a:	4603      	mov	r3, r0
 800167c:	71fb      	strb	r3, [r7, #7]
	u8 Local_u8Temp;

	/* Set A0 pin to HIGH */
	MGPIO_VidSetPinValue(TFT_A0_PIN,HIGH);
 800167e:	2201      	movs	r2, #1
 8001680:	2102      	movs	r1, #2
 8001682:	2000      	movs	r0, #0
 8001684:	f7ff fe4c 	bl	8001320 <MGPIO_VidSetPinValue>

	/* Send Data over SPI */
	MSPI1_voidSendReceiveSynch(Copy_u8Data,&Local_u8Temp);
 8001688:	f107 020f 	add.w	r2, r7, #15
 800168c:	79fb      	ldrb	r3, [r7, #7]
 800168e:	4611      	mov	r1, r2
 8001690:	4618      	mov	r0, r3
 8001692:	f7ff fecb 	bl	800142c <MSPI1_voidSendReceiveSynch>
}
 8001696:	bf00      	nop
 8001698:	3710      	adds	r7, #16
 800169a:	46bd      	mov	sp, r7
 800169c:	bd80      	pop	{r7, pc}
	...

080016a0 <HTFT_voidInitialize>:

		/* interfacing functions */
void HTFT_voidInitialize(void)
{
 80016a0:	b580      	push	{r7, lr}
 80016a2:	af00      	add	r7, sp, #0
	/* Reset Pulse */
	MGPIO_VidSetPinValue(TFT_RST_PIN,HIGH);
 80016a4:	2201      	movs	r2, #1
 80016a6:	2101      	movs	r1, #1
 80016a8:	2000      	movs	r0, #0
 80016aa:	f7ff fe39 	bl	8001320 <MGPIO_VidSetPinValue>
	MSTK_voidSetBusyWait(100);
 80016ae:	2064      	movs	r0, #100	; 0x64
 80016b0:	f7ff ff40 	bl	8001534 <MSTK_voidSetBusyWait>
	MGPIO_VidSetPinValue(TFT_RST_PIN,HIGH);
 80016b4:	2201      	movs	r2, #1
 80016b6:	2101      	movs	r1, #1
 80016b8:	2000      	movs	r0, #0
 80016ba:	f7ff fe31 	bl	8001320 <MGPIO_VidSetPinValue>
	MSTK_voidSetBusyWait(1);
 80016be:	2001      	movs	r0, #1
 80016c0:	f7ff ff38 	bl	8001534 <MSTK_voidSetBusyWait>
	MGPIO_VidSetPinValue(TFT_RST_PIN,HIGH);
 80016c4:	2201      	movs	r2, #1
 80016c6:	2101      	movs	r1, #1
 80016c8:	2000      	movs	r0, #0
 80016ca:	f7ff fe29 	bl	8001320 <MGPIO_VidSetPinValue>
	MSTK_voidSetBusyWait(100);
 80016ce:	2064      	movs	r0, #100	; 0x64
 80016d0:	f7ff ff30 	bl	8001534 <MSTK_voidSetBusyWait>
	MGPIO_VidSetPinValue(TFT_RST_PIN,HIGH);
 80016d4:	2201      	movs	r2, #1
 80016d6:	2101      	movs	r1, #1
 80016d8:	2000      	movs	r0, #0
 80016da:	f7ff fe21 	bl	8001320 <MGPIO_VidSetPinValue>
	MSTK_voidSetBusyWait(100);
 80016de:	2064      	movs	r0, #100	; 0x64
 80016e0:	f7ff ff28 	bl	8001534 <MSTK_voidSetBusyWait>
	MGPIO_VidSetPinValue(TFT_RST_PIN,HIGH);
 80016e4:	2201      	movs	r2, #1
 80016e6:	2101      	movs	r1, #1
 80016e8:	2000      	movs	r0, #0
 80016ea:	f7ff fe19 	bl	8001320 <MGPIO_VidSetPinValue>
	MSTK_voidSetBusyWait(120000);
 80016ee:	480a      	ldr	r0, [pc, #40]	; (8001718 <HTFT_voidInitialize+0x78>)
 80016f0:	f7ff ff20 	bl	8001534 <MSTK_voidSetBusyWait>

	/* sleep out command */
	voidWriteCommand(0x11);
 80016f4:	2011      	movs	r0, #17
 80016f6:	f7ff ffa8 	bl	800164a <voidWriteCommand>

	MSTK_voidSetBusyWait(150000);
 80016fa:	4808      	ldr	r0, [pc, #32]	; (800171c <HTFT_voidInitialize+0x7c>)
 80016fc:	f7ff ff1a 	bl	8001534 <MSTK_voidSetBusyWait>

	/* color mode command */
	voidWriteCommand(0x3A);
 8001700:	203a      	movs	r0, #58	; 0x3a
 8001702:	f7ff ffa2 	bl	800164a <voidWriteCommand>
	voidWriteData(0x05);
 8001706:	2005      	movs	r0, #5
 8001708:	f7ff ffb4 	bl	8001674 <voidWriteData>

	/* Display on command */
	voidWriteCommand(0x29);
 800170c:	2029      	movs	r0, #41	; 0x29
 800170e:	f7ff ff9c 	bl	800164a <voidWriteCommand>

	
}
 8001712:	bf00      	nop
 8001714:	bd80      	pop	{r7, pc}
 8001716:	bf00      	nop
 8001718:	0001d4c0 	.word	0x0001d4c0
 800171c:	000249f0 	.word	0x000249f0

08001720 <HTFT_voidDisplayImage>:

void HTFT_voidDisplayImage(const u16 * Copy_Image)
{
 8001720:	b580      	push	{r7, lr}
 8001722:	b084      	sub	sp, #16
 8001724:	af00      	add	r7, sp, #0
 8001726:	6078      	str	r0, [r7, #4]
	u16  Counter;
	/* Set 'x' address */
	voidWriteCommand(0x2A);
 8001728:	202a      	movs	r0, #42	; 0x2a
 800172a:	f7ff ff8e 	bl	800164a <voidWriteCommand>
		/* area of working */
	HTFT_voidBounders(0,127,0,159);
 800172e:	239f      	movs	r3, #159	; 0x9f
 8001730:	2200      	movs	r2, #0
 8001732:	217f      	movs	r1, #127	; 0x7f
 8001734:	2000      	movs	r0, #0
 8001736:	f7ff ff53 	bl	80015e0 <HTFT_voidBounders>

	/* RAM write */
	voidWriteCommand(0x2C);
 800173a:	202c      	movs	r0, #44	; 0x2c
 800173c:	f7ff ff85 	bl	800164a <voidWriteCommand>

	for(Counter = 0 ; Counter < 20480 ; Counter++)
 8001740:	2300      	movs	r3, #0
 8001742:	81fb      	strh	r3, [r7, #14]
 8001744:	e016      	b.n	8001774 <HTFT_voidDisplayImage+0x54>
	{
		/* write the high byte */
		voidWriteData(Copy_Image[Counter] >> 8);
 8001746:	89fb      	ldrh	r3, [r7, #14]
 8001748:	005b      	lsls	r3, r3, #1
 800174a:	687a      	ldr	r2, [r7, #4]
 800174c:	4413      	add	r3, r2
 800174e:	881b      	ldrh	r3, [r3, #0]
 8001750:	0a1b      	lsrs	r3, r3, #8
 8001752:	b29b      	uxth	r3, r3
 8001754:	b2db      	uxtb	r3, r3
 8001756:	4618      	mov	r0, r3
 8001758:	f7ff ff8c 	bl	8001674 <voidWriteData>
		/* write the low byte */
		voidWriteData(Copy_Image[Counter] & 0x00FF);
 800175c:	89fb      	ldrh	r3, [r7, #14]
 800175e:	005b      	lsls	r3, r3, #1
 8001760:	687a      	ldr	r2, [r7, #4]
 8001762:	4413      	add	r3, r2
 8001764:	881b      	ldrh	r3, [r3, #0]
 8001766:	b2db      	uxtb	r3, r3
 8001768:	4618      	mov	r0, r3
 800176a:	f7ff ff83 	bl	8001674 <voidWriteData>
	for(Counter = 0 ; Counter < 20480 ; Counter++)
 800176e:	89fb      	ldrh	r3, [r7, #14]
 8001770:	3301      	adds	r3, #1
 8001772:	81fb      	strh	r3, [r7, #14]
 8001774:	89fb      	ldrh	r3, [r7, #14]
 8001776:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 800177a:	d3e4      	bcc.n	8001746 <HTFT_voidDisplayImage+0x26>


	}

	
}
 800177c:	bf00      	nop
 800177e:	bf00      	nop
 8001780:	3710      	adds	r7, #16
 8001782:	46bd      	mov	sp, r7
 8001784:	bd80      	pop	{r7, pc}

08001786 <HTFT_voidFillColor>:

void HTFT_voidFillColor(u16  Copy_u16Color)
{
 8001786:	b580      	push	{r7, lr}
 8001788:	b084      	sub	sp, #16
 800178a:	af00      	add	r7, sp, #0
 800178c:	4603      	mov	r3, r0
 800178e:	80fb      	strh	r3, [r7, #6]
	u16  Counter;

	HTFT_voidBounders(0,127,0,159);
 8001790:	239f      	movs	r3, #159	; 0x9f
 8001792:	2200      	movs	r2, #0
 8001794:	217f      	movs	r1, #127	; 0x7f
 8001796:	2000      	movs	r0, #0
 8001798:	f7ff ff22 	bl	80015e0 <HTFT_voidBounders>

	/* RAM write */
	voidWriteCommand(0x2C);
 800179c:	202c      	movs	r0, #44	; 0x2c
 800179e:	f7ff ff54 	bl	800164a <voidWriteCommand>

	for(Counter = 0 ; Counter < 20480 ; Counter++)
 80017a2:	2300      	movs	r3, #0
 80017a4:	81fb      	strh	r3, [r7, #14]
 80017a6:	e00e      	b.n	80017c6 <HTFT_voidFillColor+0x40>
	{
		/* write the high byte */
		voidWriteData(Copy_u16Color >> 8);
 80017a8:	88fb      	ldrh	r3, [r7, #6]
 80017aa:	0a1b      	lsrs	r3, r3, #8
 80017ac:	b29b      	uxth	r3, r3
 80017ae:	b2db      	uxtb	r3, r3
 80017b0:	4618      	mov	r0, r3
 80017b2:	f7ff ff5f 	bl	8001674 <voidWriteData>
		/* write the low byte */
		voidWriteData(Copy_u16Color & 0x00FF);
 80017b6:	88fb      	ldrh	r3, [r7, #6]
 80017b8:	b2db      	uxtb	r3, r3
 80017ba:	4618      	mov	r0, r3
 80017bc:	f7ff ff5a 	bl	8001674 <voidWriteData>
	for(Counter = 0 ; Counter < 20480 ; Counter++)
 80017c0:	89fb      	ldrh	r3, [r7, #14]
 80017c2:	3301      	adds	r3, #1
 80017c4:	81fb      	strh	r3, [r7, #14]
 80017c6:	89fb      	ldrh	r3, [r7, #14]
 80017c8:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 80017cc:	d3ec      	bcc.n	80017a8 <HTFT_voidFillColor+0x22>
	}
	/* to invert color */
	//voidWriteCommand(0x21);


}
 80017ce:	bf00      	nop
 80017d0:	bf00      	nop
 80017d2:	3710      	adds	r7, #16
 80017d4:	46bd      	mov	sp, r7
 80017d6:	bd80      	pop	{r7, pc}

080017d8 <main>:
#include "TFT_interface.h"

#include "image.h"

int main(void)
{
 80017d8:	b580      	push	{r7, lr}
 80017da:	af00      	add	r7, sp, #0
	RCC_voidInitSysClock();
 80017dc:	f7ff fe4c 	bl	8001478 <RCC_voidInitSysClock>
		/* Enable GPIOA */
	RCC_voidEnableClock(RCC_APB2,2);
 80017e0:	2102      	movs	r1, #2
 80017e2:	2002      	movs	r0, #2
 80017e4:	f7ff fe58 	bl	8001498 <RCC_voidEnableClock>
		/* Enable SPI1 */
	RCC_voidEnableClock(RCC_APB2,12);
 80017e8:	210c      	movs	r1, #12
 80017ea:	2002      	movs	r0, #2
 80017ec:	f7ff fe54 	bl	8001498 <RCC_voidEnableClock>

	MGPIO_VidSetPinDirection(GPIOA,PIN1,OUTPUT_SPEED_2MHZ_PP); /* A0 */
 80017f0:	2202      	movs	r2, #2
 80017f2:	2101      	movs	r1, #1
 80017f4:	2000      	movs	r0, #0
 80017f6:	f7ff fcbb 	bl	8001170 <MGPIO_VidSetPinDirection>
	MGPIO_VidSetPinDirection(GPIOA,PIN2,OUTPUT_SPEED_2MHZ_PP); /* RST */
 80017fa:	2202      	movs	r2, #2
 80017fc:	2102      	movs	r1, #2
 80017fe:	2000      	movs	r0, #0
 8001800:	f7ff fcb6 	bl	8001170 <MGPIO_VidSetPinDirection>
	MGPIO_VidSetPinDirection(GPIOA,PIN5,OUTPUT_SPEED_10MHZ_AFPP); /* CLK */
 8001804:	2209      	movs	r2, #9
 8001806:	2105      	movs	r1, #5
 8001808:	2000      	movs	r0, #0
 800180a:	f7ff fcb1 	bl	8001170 <MGPIO_VidSetPinDirection>
	MGPIO_VidSetPinDirection(GPIOA,PIN7,OUTPUT_SPEED_10MHZ_AFPP); /* MOSI */
 800180e:	2209      	movs	r2, #9
 8001810:	2107      	movs	r1, #7
 8001812:	2000      	movs	r0, #0
 8001814:	f7ff fcac 	bl	8001170 <MGPIO_VidSetPinDirection>

	MSTK_voidInit();
 8001818:	f7ff fe80 	bl	800151c <MSTK_voidInit>

	MSPI1_voidInit();
 800181c:	f7ff fdfa 	bl	8001414 <MSPI1_voidInit>


	HTFT_voidInitialize();
 8001820:	f7ff ff3e 	bl	80016a0 <HTFT_voidInitialize>

	HTFT_voidFillColor(0xffff);
 8001824:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8001828:	f7ff ffad 	bl	8001786 <HTFT_voidFillColor>

	MSTK_voidSetBusyWait(5000);
 800182c:	f241 3088 	movw	r0, #5000	; 0x1388
 8001830:	f7ff fe80 	bl	8001534 <MSTK_voidSetBusyWait>

	HTFT_voidDisplayImage(arr);
 8001834:	4801      	ldr	r0, [pc, #4]	; (800183c <main+0x64>)
 8001836:	f7ff ff73 	bl	8001720 <HTFT_voidDisplayImage>



	for(;;);
 800183a:	e7fe      	b.n	800183a <main+0x62>
 800183c:	080018f4 	.word	0x080018f4

08001840 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8001840:	480d      	ldr	r0, [pc, #52]	; (8001878 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8001842:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8001844:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001848:	480c      	ldr	r0, [pc, #48]	; (800187c <LoopForever+0x6>)
  ldr r1, =_edata
 800184a:	490d      	ldr	r1, [pc, #52]	; (8001880 <LoopForever+0xa>)
  ldr r2, =_sidata
 800184c:	4a0d      	ldr	r2, [pc, #52]	; (8001884 <LoopForever+0xe>)
  movs r3, #0
 800184e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001850:	e002      	b.n	8001858 <LoopCopyDataInit>

08001852 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001852:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001854:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001856:	3304      	adds	r3, #4

08001858 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001858:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800185a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800185c:	d3f9      	bcc.n	8001852 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800185e:	4a0a      	ldr	r2, [pc, #40]	; (8001888 <LoopForever+0x12>)
  ldr r4, =_ebss
 8001860:	4c0a      	ldr	r4, [pc, #40]	; (800188c <LoopForever+0x16>)
  movs r3, #0
 8001862:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001864:	e001      	b.n	800186a <LoopFillZerobss>

08001866 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001866:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001868:	3204      	adds	r2, #4

0800186a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800186a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800186c:	d3fb      	bcc.n	8001866 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800186e:	f000 f811 	bl	8001894 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8001872:	f7ff ffb1 	bl	80017d8 <main>

08001876 <LoopForever>:

LoopForever:
  b LoopForever
 8001876:	e7fe      	b.n	8001876 <LoopForever>
  ldr   r0, =_estack
 8001878:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 800187c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001880:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 8001884:	0800b8fc 	.word	0x0800b8fc
  ldr r2, =_sbss
 8001888:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 800188c:	20000024 	.word	0x20000024

08001890 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001890:	e7fe      	b.n	8001890 <ADC1_2_IRQHandler>
	...

08001894 <__libc_init_array>:
 8001894:	b570      	push	{r4, r5, r6, lr}
 8001896:	2600      	movs	r6, #0
 8001898:	4d0c      	ldr	r5, [pc, #48]	; (80018cc <__libc_init_array+0x38>)
 800189a:	4c0d      	ldr	r4, [pc, #52]	; (80018d0 <__libc_init_array+0x3c>)
 800189c:	1b64      	subs	r4, r4, r5
 800189e:	10a4      	asrs	r4, r4, #2
 80018a0:	42a6      	cmp	r6, r4
 80018a2:	d109      	bne.n	80018b8 <__libc_init_array+0x24>
 80018a4:	f000 f81a 	bl	80018dc <_init>
 80018a8:	2600      	movs	r6, #0
 80018aa:	4d0a      	ldr	r5, [pc, #40]	; (80018d4 <__libc_init_array+0x40>)
 80018ac:	4c0a      	ldr	r4, [pc, #40]	; (80018d8 <__libc_init_array+0x44>)
 80018ae:	1b64      	subs	r4, r4, r5
 80018b0:	10a4      	asrs	r4, r4, #2
 80018b2:	42a6      	cmp	r6, r4
 80018b4:	d105      	bne.n	80018c2 <__libc_init_array+0x2e>
 80018b6:	bd70      	pop	{r4, r5, r6, pc}
 80018b8:	f855 3b04 	ldr.w	r3, [r5], #4
 80018bc:	4798      	blx	r3
 80018be:	3601      	adds	r6, #1
 80018c0:	e7ee      	b.n	80018a0 <__libc_init_array+0xc>
 80018c2:	f855 3b04 	ldr.w	r3, [r5], #4
 80018c6:	4798      	blx	r3
 80018c8:	3601      	adds	r6, #1
 80018ca:	e7f2      	b.n	80018b2 <__libc_init_array+0x1e>
 80018cc:	0800b8f4 	.word	0x0800b8f4
 80018d0:	0800b8f4 	.word	0x0800b8f4
 80018d4:	0800b8f4 	.word	0x0800b8f4
 80018d8:	0800b8f8 	.word	0x0800b8f8

080018dc <_init>:
 80018dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80018de:	bf00      	nop
 80018e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80018e2:	bc08      	pop	{r3}
 80018e4:	469e      	mov	lr, r3
 80018e6:	4770      	bx	lr

080018e8 <_fini>:
 80018e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80018ea:	bf00      	nop
 80018ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80018ee:	bc08      	pop	{r3}
 80018f0:	469e      	mov	lr, r3
 80018f2:	4770      	bx	lr
